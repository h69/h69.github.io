(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{350:function(t,e,a){t.exports=a.p+"assets/img/01.3c3d3425.png"},351:function(t,e,a){t.exports=a.p+"assets/img/02.55b56a64.jpg"},352:function(t,e,a){t.exports=a.p+"assets/img/03.01a70dff.png"},353:function(t,e,a){t.exports=a.p+"assets/img/04.24151f0f.png"},354:function(t,e,a){t.exports=a.p+"assets/img/05.7b9fb557.jpeg"},398:function(t,e,a){"use strict";a.r(e);var r=a(25),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"wireguard"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#wireguard"}},[t._v("#")]),t._v(" WireGuard")]),t._v(" "),r("p",[r("img",{attrs:{src:a(350),alt:""}})]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/pirate/wireguard-docs",target:"_blank",rel:"noopener noreferrer"}},[t._v("WireGuard"),r("OutboundLink")],1),t._v(" 是一个易于配置、快速且安全的开源 VPN，它利用了最新的加密技术 —— ECDH 算法，提供一种更快、更简单、更安全的通用 VPN，WireGuard 被视为下一代 VPN 协议，用来替代 OpenVPN、IPSec 等，并且它可以轻松地在树莓派这类低端设备到高端服务器上部署，当前已经被吸收进了 Linux 5.6+ 的内核中，总共只有不到四千行代码。")]),t._v(" "),r("p",[t._v("WireGuard 最初是为 Linux 开发的，但现在可用于 Windows、macOS、iOS 和 Android 等平台上。")]),t._v(" "),r("h2",{attrs:{id:"性能对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#性能对比"}},[t._v("#")]),t._v(" 性能对比")]),t._v(" "),r("p",[r("img",{attrs:{src:a(351),alt:""}})]),t._v(" "),r("h2",{attrs:{id:"工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[t._v("#")]),t._v(" 工作原理")]),t._v(" "),r("h3",{attrs:{id:"连接过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#连接过程"}},[t._v("#")]),t._v(" 连接过程")]),t._v(" "),r("p",[r("img",{attrs:{src:a(352),alt:""}})]),t._v(" "),r("p",[t._v("正常情况下，WireGuard 只需要 1 个 RTT 的握手就会建立连接状态，然后就开始传输数据了。在握手的过程中交换了对称密钥，一个用来发送，一个用来接收，并且在路由表中生成了对方的地址。")]),t._v(" "),r("blockquote",[r("p",[t._v("在负载较重的时候，WireGuard 会要求 2 个 RTT 的握手。")])]),t._v(" "),r("p",[t._v("一、握手请求报文：")]),t._v(" "),r("ul",[r("li",[t._v("unencrypted_ephemeral：发送方为这次握手临时生成的公钥（未加密，用于 ECDH）")]),t._v(" "),r("li",[t._v("encrypted_static：用对方的公钥和临时生成的私钥 ECDH 出的临时密钥 key1 对称加密对方的公钥")]),t._v(" "),r("li",[t._v("encrypted_timestamp：用对方的公钥和自己的私钥 ECDH 出 key2，key2 混淆进 key1，来加密当前的时间戳")]),t._v(" "),r("li",[t._v("mac1：对方的公钥加上整个报文内容后的哈希")])]),t._v(" "),r("p",[t._v("二、握手回复报文：")]),t._v(" "),r("ul",[r("li",[t._v("unencrypted_ephemeral：接收方为这次握手临时生成的公钥（未加密，用于 ECDH）")]),t._v(" "),r("li",[t._v("mac1：对方的公钥加上整个报文内容后的哈希")])]),t._v(" "),r("p",[t._v("这样两端都有对方的临时生成的公钥，加上自己临时生成的私钥，就可以 ECDH + HKDF（一种把 DH 结果转成对称加密密钥的方法）得到这次握手的两个方向的对称加密的密钥。")]),t._v(" "),r("h3",{attrs:{id:"传输过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#传输过程"}},[t._v("#")]),t._v(" 传输过程")]),t._v(" "),r("p",[r("img",{attrs:{src:a(353),alt:""}})]),t._v(" "),r("p",[t._v("WireGuard 以 UDP 实现，但是运行在第三层 —— IP 层（网络层）。每个 WireGuard Peer（节点） 都会生成一个 "),r("code",[t._v("wg0")]),t._v(" 虚拟网卡。应用程序的包发送到内核以后，如果地址是虚拟专用网内部的，那么就会交给 "),r("code",[t._v("wg0")]),t._v(" 设备，WireGuard 就会把这个 IP 包封装成 WireGuard 的包，然后在 UDP 中发送出去，对方的 Peer 的内核收到这个 UDP 包后再反向操作，解包成为 IP 包，然后交给对应的应用程序。")]),t._v(" "),r("h2",{attrs:{id:"配置方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#配置方法"}},[t._v("#")]),t._v(" 配置方法")]),t._v(" "),r("p",[r("img",{attrs:{src:a(354),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"公私钥"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#公私钥"}},[t._v("#")]),t._v(" 公私钥")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("# 每一个节点都需要生成一对公私钥\nwg genkey | tee private | wg pubkey > public\n")])])]),r("h3",{attrs:{id:"服务端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端"}},[t._v("#")]),t._v(" 服务端")]),t._v(" "),r("div",{staticClass:"language-conf extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("# /etc/wireguard/wg0.conf\n\n[Interface]\n# 服务端私钥\nPrivateKey =\nAddress = 10.10.10.1\nSaveConfig = true\nListenPort = 51820\nPostUp   = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\nPostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE\n\n\n# 配置客户端的 IP（多个客户端连接用多个 Peer 来配置）\n[Peer]\n# 客户端公钥\nPublicKey =\n# 表示只代理该 IP 过来的流量（支持网段）\nAllowedIPs = 10.10.10.2/32\n# 表示代理所有流量\n# AllowedIPs = 0.0.0.0/0\n")])])]),r("h3",{attrs:{id:"客户端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[t._v("#")]),t._v(" 客户端")]),t._v(" "),r("div",{staticClass:"language-conf extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("[Interface]\n# 客户端私钥\nPrivateKey =\nAddress = 10.10.10.2/32\nDNS = 8.8.8.8\n\n[Peer]\n# 服务端公钥\nPublicKey =\n# 服务端公网地址\nEndpoint = 149.28.171.194:51820\n# 表示只劫持该 IP 的流量（支持网段）\nAllowedIPs = 10.100.0.0/16,172.17.0.11/20\n# 表示劫持所有流量\n# AllowedIPs = 0.0.0.0/0\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);